# ComputerNetwork

学习自牛客网面试宝典以及GitHub
参考博客内容：

* <https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md>
* <https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md>
* <https://www.nowcoder.com/tutorial/93/e1b14ab2b40a4ef98d9e55830eb48d66>
* <https://blog.csdn.net/justloveyou_/article/details/78303617>
* [面试/笔试第一弹 —— 计算机网络面试问题集锦](https://blog.csdn.net/justloveyou_/article/details/78303617)

参考书籍

* 计算机网络, 谢希仁
---

## 计算机网络概述部分，有待补充

### OSI七层协议模型

* 七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。
* 五层体系结构包括： 应用层，运输层，网络层，数据链路层和物理层。五层知识OSI和TCP/IP 的综合，实际应用还是TCP/IP的四层结构，为了方便可以把下两层称为网络接口
* 四层TCP/IP模型： 应用层（Telent，FTP等），传输层（TCP和UDP），网络层（IP，ICMP,IGMP），链路层



详细参考：

[OSI 七层模型和TCP/IP模型及对应协议（详解）--CSDN](https://blog.csdn.net/qq_41923622/article/details/85805003)



---

### 五层协议

五层协议由上到下

* **应用层** ：为特定应用程序提供数据传输服务。应用层的协议有很多，例如 支持万维网应用的HTTP协议、支持文件传送的DNS协议 等协议。数据单位为报文。

* **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用
的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，**提供面向连接、可靠的数据传输服务**，数据单位为报文段；用户数据报协议 UDP，**提供无连接、尽最大努力的数据传输服务**，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

* **网络层** ：为**主机**提供数据传输服务。而传输层协议是为**主机中的进程**提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。网络层主要包括两个任务：（1）负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。（2）选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。常见协议：IP,ICMP,IGMP,ARP,RARP

* **数据链路层** ：常简称为链路层。网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

* **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。**透明的传输比特流**

---

## 应用层

参考了计网课件

### 域名系统

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

* 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
* 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

### 文件传送协议

常见的有FTP协议，SFTP协议等。

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

* 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
* 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

* 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。
* 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。

#### 动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

#### 远程登陆协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

#### 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

#### web页面请求过程

//TODO web页面请求过程待补充

1.浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

2.浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；

3.TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；

4.服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

5.浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；

6.浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。


```txt
其中：

1、DNS协议，http协议，https协议属于应用层

应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。

2、TCP/UDP属于传输层

传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。

3、IP协议，ARP协议属于网络层

网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。
4、数据链路层

当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。
5、物理层

物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。
```


## 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细
节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

重要的是TCP的三次握手、四次挥手，可靠传输的原理，滑动窗口的理解

### UDP和TCP

* 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。
<br>
* 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

### UDP 和 TCP 的首部格式

参照课件或者网上博客

首部格式中重要的是序列号seq，确认号ack，以及标志位

* 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
* 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

| 字段 |                             含义                             |
| ---- | :----------------------------------------------------------: |
| URG  |       紧急指针是否有效。为1，表示某一位需要被优先处理        |
| ACK  |                 确认号是否有效，一般置为1。                  |
| PSH  |        提示接收端应用程序立即从TCP缓冲区把数据读走。         |
| RST  |                 对方要求重新建立连接，复位。                 |
| SYN  | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 |
| FIN  |                        希望断开连接。                        |




### **TCP的三次握手**

* 第一次握手：Client将SYN置1，ACK置0，随机产生一个初始序列号seq=x，发送请求连接报文给给Server，进入SYN_SENT状态；
<br>
* 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number（确认号ack）=x+1，并随机产生一个自己的初始序列号seq=y，发送给客户端；进入SYN_RCVD状态；
<br>
* 第三次握手：客户端检查acknowledge number是否为序列号x+1，ACK是否为1；检查正确之后将自己的ACK置为1、产生一个acknowledge number（确认号ack）=服务器发的序列号y+1、产生序列号seq=x+1发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number（确认号ack）为序列号x+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。

#### 三次握手的原因

参考：
牛客网讨论区

* <https://www.nowcoder.com/tutorial/93/e1b14ab2b40a4ef98d9e55830eb48d66>
* <https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md>

1>从资源角度
防止： 已经失效的连接请求报文段有传到了服务器端

```txt
client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的
滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已
失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client
再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连
接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。
由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，
也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直
等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三
次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向
server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要
求建立连接。
```

2> 可能会产生死锁

* 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

```txt
现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S
和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确
认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数
据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备
好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这
种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确
认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
```

前两点回答的重点是不能两次握手
第三点是四次握手
3> 四次握手，可以但没必要

* 降低传输的效率。

四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。

#### 三次握手中客户端的ACK未送达服务器，会怎样？

* 由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接），Client收到后会重新传ACK给Server。如果Client向服务器发送数据，服务器会以RST包响应

#### 如果建立完成，但是客户端出现了故障，如何处理?

* 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### TCP四次挥手

* 第一次挥手：Client将FIN置为1，发送一个序列号seq=x给Server；进入FIN_WAIT状态；
* 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=x+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
* 第三次挥手：Server将FIN置1，发送一个序列号y给Client；进入LAST_ACK状态；
* 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=y+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。

#### 四次挥手的原因

##### 第二次挥手和第三次挥手不能合并的原因

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。(CLOSE_WAIT状态的意义所在)。

##### 客户端TIME_WAIT状态的意义

第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重
发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在
2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收
到ACK而不断重发FIN。

MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### TCP可靠传输

TCP 通过：

1. 序列号、确认应答、超时重传
2. 窗口控制与高速重发控制/快速重传（重复确认应答）
3. 拥塞控制

方式来保证传输的可靠性

#### 序列号、确认应答、超时重传

数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。

#### 窗口控制与高速重发控制/快速重传（重复确认应答）

TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。

使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发

#### 拥塞控制

如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。

### TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

### TCP流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。

若将接收窗口字段设置为 0，称为零窗口。如果接收方没有能力接收数据，则将接收窗口置为0，此时发送方不能发送数据。当时会启动一个持续计时器，到期后发送一个大小为1字节的探测数据包探测接收窗口状态，如果能接收数据，则在返回的报文中更新接收窗口大小，恢复数据传送

#### 流量控制和拥塞控制的区别

* 流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 

  

* 拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。

流量控制是点对点（端对端），拥塞控制是针对整个网络。

### TCP拥塞控制的算法

网络拥塞的缺点：如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。

拥塞控制的四个算法：

#### 慢启动

刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍

#### 拥塞避免

当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.

---
无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。（这是不使用快重传的情况）

---

#### 快重传

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

#### 快恢复

当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。

### TCP与UDP小结

1. TCP是面向连接的，UDP是无连接的。
    什么是无连接？UDP发送数据之前不需要建立连接

2. TCP是可靠的，UDP是不可靠的
    UDP接收方收到报文之后，不需要给出任何确认

3. TCP只支持点对点通信，UDP支持一对一，一对多，多对一，多对多通信

4. TCP是面向字节流的，UDP面向报文的
    面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送；UDP一个报文只能一次发完

5. TCP有拥塞控制机制，UDP则没有。
6. TCP头开销需要20字节，UDP只需要8字节
7. UDP的主机不需要维持复杂的连接状态

一些应用实时性要求较高的，选择UDP，比如游戏，媒体通信，实时视频流（直播），这些即使出现传输错误也是可以容忍的。其他大部分情况下，HTTP都用TCP，因为要求传输的内容可靠（UDP是不可靠的），不出现丢失。

* 有关TCP粘包、有界无界问题，参考博客：

[面向报文（UDP）和面向字节流（TCP）的区别--CSDN](https://blog.csdn.net/ce123_zhouwei/article/details/8976006)



## 网络层

网络层仅列出大纲，可以参看计网课程课件

* IP数据报格式
* IP地址编址方式

    * 分类
    * 子网划分
  
* 地址解析协议-ARP
* 网络控制报文协议ICMP
* 虚拟专用网络 VPN
* 网络地址转换 NAT
* 路由器的结构
* 路由器分组转发流程
* 路由选择协议
    * 内部网关协议
      * RIP
      * OSPF
    * 外部网关协议
      * BGP



#### ARP协议

**ARP协议完成了IP地址与物理地址的映射**。每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。

**ARP劫持？**：



## 数据链路层

数据链路层可以看计网课程课件，此处只列出大纲

* 基本问题
    * 1. 封装成帧
    * 2. 透明传输
    * 3. 差错检测
* 信道分类
    * 1. 广播信道
    * 2. 点对点信道
* 信道复用技术
    * 1. 频分复用
    * 2. 时分复用
    * 3. 统计时分复用
    * 4. 波分复用
    * 5. 码分复用
* CSMA/CD 协议
* PPP 协议
* MAC 地址
* 局域网
* 以太网
* 交换机
* 虚拟局域网
* 六个基本数据链路层协议（模拟实现，见计网作业）

# http/https 相关
---
参考博客

1. <https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md>
2. <https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md>
3. <https://www.cnblogs.com/linliquan/p/11362336.html>



### 响应码





### Get和Post的区别





### Cookie和Session



#### CA证书

[CA认证的原理和流程及https原理](https://www.cnblogs.com/yunlongaimeng/p/9417276.html)



#### 输入url的过程

[HTTP协议详解以及URL具体访问过程](https://www.cnblogs.com/phpstudy2015-6/p/6810130.html)

从大致上来讲经历了

客户端获取URL - > DNS解析 - > TCP连接 - >发送HTTP请求 - >服务器处理请求 - >返回报文 - >浏览器解析渲染页面 - > TCP断开连接

详细文字讲解！

客户端：

（应用层开始）获取URL，通过负责域名解析的DNS服务获取网址的IP地址，根据HTT协议生成HTTP请求报文（应用层结束）

（传输层开始）根据TCP协议连接从客户端到服务端（通过三次握手）客户端给服务端发送一个带SYN（同步）标志的数据包给客户端，然后客户端接收到信息再给客户端回传一个带有SYN / ACK（确认）标志的数据包以示传达确认信息，客户求最后端的再传送一个带ACK标志的数据包，代表“握手”结束，连接成功.TCP协议在把请求报文按序号分割成多个报文段（传输层结束）

（网络层开始）根据IP协议（传输数据），ARP协议（获取MAC地址），OSPF协议（选择最优路径），搜索服务器地址，一边中转一边传输数据（网络层结束）

（数据链路层开始）到达后通过数据链路层，物理层负责0,1比特流与物理设备电压高低，光的闪灭之间的互换。数据链路层负责将0,1序列划分为数据帧从一个节点传输到临近的另一个节点，这些节点是通过MAC来唯一标识的（MAC，物理地址，一个中主机会有一个MAC地址）。 （数据链路层结束）

服务端

通过数据链路层 - >通过网络层 - >再通过传输层（根据TCP协议接收请求报文并重组报文段） - >再通过应用层（通过HTTP协议对请求的内容进行处理） - >再通过应用层 - >传输层 - >网络层 - >数据链路层 - >到达客户端

客户端

通过数据链路层 - >网络层 - >传输层（根据TCP协议接收响应报文并重组） - >应用层（HTTP协议对响应进行处理） - >浏览器渲染页面 - >断开连接协议四次挥手） 

四次挥手

主动方发送标志位：（ACK + FIN）+（发送序号= 200 +确认序号= 500）第一次挥手

被动方接收后发送标志位：ACK +（发送序号=主动方确认序号500 +确认序号=主动方发送序号+1201）第二次挥手

 标志位：（ACK + FIN）+（发送序号=主动方确认序号+1 501）第三次挥手

主动方接收后发送标志位：（ACK）+（发送序号=被动方的确认序号201 +确认序号=被动方的发生序号+1502）


# Socket 相关
---
参考博客：

<https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md>



### select ：



### poll：





### epoll

#### 请你回答一下epoll怎么实现的：

Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。






# 相关基础知识

#### 大小端问题



[大小端及网络字节序--CSDN](https://blog.csdn.net/z_ryan/article/details/79134980)

#### ping命令

**PING是应用层直接使用网络层ICMP的一个例子，它没有通过运输层的TCP或UDP**

ping是一个基本的网络命令，用来确定网络上具有某个特定IP地址的主机是否存在以及是否能接收请求。 

   Ping命令通过向计算机发送**ICMP回应报文**并且监听回应报文的返回，以校验与远程计算机或本地计算机的连接。对于每个发送报文，Ping最多等待1秒，并打印发送和接收把报文的数量。比较每个接收报文和发送报文，以校验其有效性。默认情况下，发送四个回应报文，每个报文包含64字节的数据（周期性的大写字母序列）。 

  网络层包括：IP(Internet  Protocol）协议、ICMP(Internet Control Message Protocol)
  控制报文协议、ARP(Address Resolution Protocol）地址转换协议、RARP(Reverse  ARP)反向地址转换协议。
 IP是网络层的核心，通过路由选择将下一条IP封装后交给接口层。IP数据报是无连接服务。
  ICMP是网络层的补充，可以回送报文。用来检测网络是否通畅。
 Ping命令就是发送ICMP的echo包，通过回送的echo  relay进行网络测试。



#### 交换机和路由器的区别

路由器是网络层，根据ip地址进行寻址，使用IPv4或者IPv6协议

交换机是在数据链路层，根据mac地址进行寻址，使用mac寻址



转发表（MAC）、ARP表、路由表总结参考博客：

[转发表(MAC表)、ARP表、路由表总结](https://cloud.tencent.com/developer/article/1173761)





#### MSS MTU

***MTU***： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小；以普遍使用的以太网接口为例，缺省MTU=1500 Byte，这是以太网接口对IP层的约束，如果IP层有<=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有> 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。

***MSS***：Maximum Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，MSS是TCP用来限制application层最大的发送字节数。如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。

